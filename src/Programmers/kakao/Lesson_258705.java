package Programmers.kakao;

/*
2024 KAKAO WINTER INTERNSHIP
산 모양 타일링
https://school.programmers.co.kr/learn/courses/30/lessons/258705
 */
public class Lesson_258705 {

    // modification의 줄임말
    private final static int MOD = 10007;

    // 앞에서 침범하지에 대해 집중하여 볼 것
    public int solution(int n, int[] tops) {
        // 각 윗변마다 나올 수 있는 경우의 수 누적 배열
        // int[윗변의 순서][0] : 내가 뒤를 침범하지 않았을 때 나올 수 있는 경우의 수
        // int[윗변의 순서][1] : 내가 뒤를 침범했을 때 나올 수 있는 경우의 수
        int[][] dp = new int[n][2];

        /*
            위에 정삼각형을 붙였을 때( tops[i]==1 )
             - 내가 뒤에 정삼각형을 침범하지 않고 -> (총 5가지)
                - 앞에서 침범하지 않을 경우 - 왼쪽 아래를 포함한 사다리꼴, 중앙 마름모, 마름모/사다리꼴이 없는 경우 -> (3가지)
                - 앞에서 침범했을 경우 - 중앙 마름모, 마름모/사다리꼴이 없는 경우 -> (2가지)
             - 내가 뒤에 정삼각형을 침범하고 -> (총 2가지)
                - 앞에서 침범하지 않을 경우 - 오른쪽 아래를 포함한 사다리꼴 -> (1가지)
                - 앞에서 침범했을 경우 - 오른쪽 아래를 포함한 사다리꼴 -> (1가지)
            위에 정삼각형을 붙지 않았을 때( tops[i]==0 )
             - 내가 뒤에 정삼각형을 침범하지 않고 -> (총 3가지)
                - 앞에서 침범하지 않을 경우 - 왼쪽 아래를 포함한 사다리꼴, 마름모/사다리꼴이 없는 경우 -> (2가지)
                - 앞에서 침범했을 경우 - 마름모/사다리꼴이 없는 경우 -> (1가지)
             - 내가 뒤에 정삼각형을 침범하고 -> (총 2가지)
                - 앞에서 침범하지 않을 경우 - 오른쪽 아래를 포함한 사다리꼴 -> (1가지)
                - 앞에서 침범했을 경우 - 오른쪽 아래를 포함한 사다리꼴 -> (1가지)

         */

        // 첫번째 윗변에 삼각형이 붙는지 안붙는지에 따라 경우의 수 결정
        //  - 정삼각형이 붙는 경우 => 왼쪽 아래를 포함한 사다리꼴, 중앙 마름모, 마름모/사다리꼴이 없는 경우 (3가지)
        //  - 정삼각형이 붙지 않는 경우 => 왼쪽 아래를 포함한 사다리꼴, 마름모/사다리꼴이 없는 경우 (2가지)
        dp[0][0] = tops[0] == 1 ? 3 : 2;
        // 내가 뒤에 정삼각형을 침범하는 경우 1가지
        dp[0][1] = 1;
        // 첫번째 윗변은 위에서 결정했으니 두번째 윗변부터 확인
        for(int i=1; i<n; i++) {
            // 내가 뒤를 침범하는 경우
            // (앞에서 침범해온 경우 + 침범해오지 않았을 경우) % 10007 저장
            dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD;
            // 위에 정삼각형이 붙는다면
            if(tops[i] == 1) {
                // 앞에서 침범하지 않는 경우(이전까지의 총합) * 내가 만들 수 있는 경우의 수 3가지
                // 앞에서 침범하는 경우(이전까찌의 총합) * 내가 만들 수 있는 경우의수 2가지
                // 위에 두 값을 더한 후 % 10007 저장
                dp[i][0] = (dp[i-1][0] * 3 + dp[i-1][1] * 2) % MOD;
            }
            // 위에 정삼각형이 붙지 않는다면
            else {
                // 앞에서 침범하지 않는 경우(이전까지의 총합) * 내가 만들 수 있는 경우의 수 2가지
                // 앞에서 침범하는 경우(이전까찌의 총합) [(* 내가 만들 수 있는 경우의수 1가지) -> 생략]
                // 위에 두 값을 더한 후 % 10007 저장
                dp[i][0] = (dp[i-1][0] * 2 + dp[i-1][1]) % MOD;
            }
        }

        // 가장 마지막 삼각형까지의 모든 경우의 수 합을 10007로 나눈 나머지 값 반환
        return (dp[n-1][0] + dp[n-1][1]) % MOD;
    }


    /*
    4	[1, 1, 0, 1]	149
    2	[0, 1]	11
    10	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]	7704
     */
    public static void main(String[] args) {
        Lesson_258705 lesson = new Lesson_258705();
//        int n = 4;
//        int n = 2;
        int n = 10;
//        int[] tops = {1, 1, 0, 1};
//        int[] tops = {0, 1};
        int[] tops = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        int result = lesson.solution(n, tops);
        System.out.println(result);
    }
}
